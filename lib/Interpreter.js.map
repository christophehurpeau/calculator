{"version":3,"sources":["../src/Interpreter.js"],"names":[],"mappings":"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","file":"Interpreter.js","sourcesContent":["import Token from './Token';\n\nconst INTEGER = Symbol('INTEGER');\nconst PLUS = Symbol('PLUS');\nconst MINUS = Symbol('MINUS');\nconst EOF = Symbol('EOF');\n\nconst isNumber = /^[0-9]$/;\nconst isWhitespace = /^\\s$/;\n\nexport default class Interpreter {\n    constructor(text) {\n        this.text = text;\n        this.position = 0;\n        this.currentToken = undefined;\n    }\n\n    getCurrentChar() {\n        return this.text.charAt(this.position);\n    }\n\n    hasNextChar() {\n        return this.position < this.text.length;\n    }\n\n    getNextChar() {\n        this.position++;\n        return this.getCurrentChar();\n    }\n\n    /**\n     * Lexical analyzer (also known as scanner or tokenizer)\n     * This method is responsible for breaking a sentence\n     * apart into tokens. One token at a time.\n     */\n    getNextToken() {\n        // is this.position index past the end of the this.text ?\n        // if so, then return EOF token because there is no more\n        if (!this.hasNextChar()) {\n            return new Token(EOF);\n        }\n\n        let currentChar = this.getCurrentChar();\n\n        if (isWhitespace.test(currentChar)) {\n            this.position++;\n            return this.getNextToken();\n        }\n\n        // if the character is a digit then convert it to\n        // integer, create an INTEGER token, increment this.position\n        // index to point to the next character after the digit,\n        // and return the INTEGER token\n        if (isNumber.test(currentChar)) {\n            let buffer = '';\n            do {\n                buffer += currentChar;\n                currentChar = this.getNextChar();\n            } while (isNumber.test(currentChar));\n\n            return new Token(INTEGER, Number.parseInt(buffer, 10));\n        }\n\n        if (currentChar === '+') {\n            this.position++;\n            return new Token(PLUS, currentChar);\n        }\n\n        if (currentChar === '-') {\n            this.position++;\n            return new Token(MINUS, currentChar);\n        }\n\n        throw new Error('Error parsing input at position ' + this.position);\n    }\n\n    /**\n     * @param {Symbol|Symbol[]} tokenTypes\n     */\n    eat(tokenTypes) {\n        // compare the current token type with the passed token\n        // type and if they match then \"eat\" the current token\n        // and assign the next token to the this.currentToken,\n        // otherwise raise an exception.\n\n        if (!Array.isArray(tokenTypes)) {\n            tokenTypes = [tokenTypes];\n        }\n\n        if (tokenTypes.indexOf(this.currentToken.type) === -1) {\n            throw new Error('Expecting ' + tokenTypes.map(s => s.toString()).join(' or ')\n                            + ', got ' + this.currentToken.type.toString());\n        }\n\n        this.currentToken = this.getNextToken();\n    }\n\n    /**\n     * expr -> INTEGER PLUS INTEGER\n     */\n    expr() {\n        // set current token to the first token taken from the input\n        this.currentToken = this.getNextToken();\n\n        if (this.currentToken.type === EOF) {\n            return undefined;\n        }\n\n        // we expect the current token to be a single-digit integer\n        const left = this.currentToken;\n        this.eat(INTEGER);\n\n        // we expect the current token to be a '+' token\n        const operation = this.currentToken;\n        this.eat([PLUS, MINUS]);\n\n        // we expect the current token to be a single-digit integer\n        const right = this.currentToken;\n        this.eat(INTEGER);\n\n        // after the above call the this.currentToken is set to EOF\n\n        // at this point INTEGER PLUS INTEGER sequence of tokens\n        // has been successfully found and the method can just\n        // return the result of adding two integers, thus\n        // effectively interpreting client input\n        switch (operation.type) {\n            case PLUS:\n                return left.value + right.value;\n            case MINUS:\n                return left.value - right.value;\n        }\n    }\n\n}\n"]}