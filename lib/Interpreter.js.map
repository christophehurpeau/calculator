{"version":3,"sources":["../src/Interpreter.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;qBAAkB,SAAS;;;;AAE3B,IAAM,OAAO,GAAG,QAAO,SAAS,CAAC,CAAC;AAClC,IAAM,IAAI,GAAG,QAAO,MAAM,CAAC,CAAC;AAC5B,IAAM,GAAG,GAAG,QAAO,KAAK,CAAC,CAAC;;AAE1B,IAAM,QAAQ,GAAG,SAAS,CAAC;;;;IAEN,WAAW;AACjB,aADM,WAAW,CAChB,IAAI,EAAE;8BADD,WAAW;;AAExB,YAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACjB,YAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;AAClB,YAAI,CAAC,YAAY,GAAG,SAAS,CAAC;KACjC;;;;;;;;;;;iBALgB,WAAW;;eAYhB,wBAAG;;;AAGX,gBAAI,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;AACtC,uBAAO,uBAAU,GAAG,CAAC,CAAC;aACzB;;;;AAID,gBAAI,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;;;;;;AAMlD,gBAAI,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;AAC5B,oBAAI,MAAM,GAAG,EAAE,CAAC;AAChB,mBAAG;AACC,0BAAM,IAAI,WAAW,CAAC;AACtB,wBAAI,CAAC,QAAQ,EAAE,CAAC;AAChB,+BAAW,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;iBACjD,QAAQ,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;AACrC,uBAAO,uBAAU,OAAO,EAAE,iBAAgB,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC;aAC1D;;AAED,gBAAI,WAAW,KAAK,GAAG,EAAE;AACrB,oBAAM,KAAK,GAAG,uBAAU,IAAI,EAAE,WAAW,CAAC,CAAC;AAC3C,oBAAI,CAAC,QAAQ,EAAE,CAAC;AAChB,uBAAO,KAAK,CAAC;aAChB;;AAED,kBAAM,IAAI,KAAK,CAAC,kCAAkC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC;SACvE;;;;;;;;;;;eAKE,aAAC,SAAS,EAAE;;;;;;AAMX,gBAAI,IAAI,CAAC,YAAY,CAAC,IAAI,KAAK,SAAS,EAAE;AACtC,sBAAM,IAAI,KAAK,CAAC,YAAY,GAAG,SAAS,CAAC,QAAQ,EAAE,GAAG,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;aACvG;;AAED,gBAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;SAC3C;;;;;;;;;;eAKG,gBAAG;;AAEH,gBAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;;;AAGxC,gBAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC;AAC/B,gBAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;;;AAGlB,gBAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC;AACpC,gBAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;;;AAGf,gBAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC;AAChC,gBAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;;;;;;;;AAQlB,mBAAO,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;SACnC;;;WAxFgB,WAAW;;;qBAAX,WAAW","file":"Interpreter.js","sourcesContent":["import Token from './Token';\n\nconst INTEGER = Symbol('INTEGER');\nconst PLUS = Symbol('PLUS');\nconst EOF = Symbol('EOF');\n\nconst isNumber = /^[0-9]$/;\n\nexport default class Interpreter {\n    constructor(text) {\n        this.text = text;\n        this.position = 0;\n        this.currentToken = undefined;\n    }\n\n    /**\n     * Lexical analyzer (also known as scanner or tokenizer)\n     * This method is responsible for breaking a sentence\n     * apart into tokens. One token at a time.\n     */\n    getNextToken() {\n        // is this.position index past the end of the this.text ?\n        // if so, then return EOF token because there is no more\n        if (this.position > this.text.length - 1) {\n            return new Token(EOF);\n        }\n\n        // get a character at the position this.position and decide\n        // what token to create based on the single character\n        let currentChar = this.text.charAt(this.position);\n\n        // if the character is a digit then convert it to\n        // integer, create an INTEGER token, increment this.position\n        // index to point to the next character after the digit,\n        // and return the INTEGER token\n        if (isNumber.test(currentChar)) {\n            let buffer = '';\n            do {\n                buffer += currentChar;\n                this.position++;\n                currentChar = this.text.charAt(this.position);\n            } while (isNumber.test(currentChar));\n            return new Token(INTEGER, Number.parseInt(buffer, 10));\n        }\n\n        if (currentChar === '+') {\n            const token = new Token(PLUS, currentChar);\n            this.position++;\n            return token;\n        }\n\n        throw new Error('Error parsing input at position ' + this.position);\n    }\n\n    /**\n     * @param {Symbol} tokenType\n     */\n    eat(tokenType) {\n        // compare the current token type with the passed token\n        // type and if they match then \"eat\" the current token\n        // and assign the next token to the this.currentToken,\n        // otherwise raise an exception.\n\n        if (this.currentToken.type !== tokenType) {\n            throw new Error('Expecting ' + tokenType.toString() + ', got ' + this.currentToken.type.toString());\n        }\n\n        this.currentToken = this.getNextToken();\n    }\n\n    /**\n     * expr -> INTEGER PLUS INTEGER\n     */\n    expr() {\n        // set current token to the first token taken from the input\n        this.currentToken = this.getNextToken();\n\n        // we expect the current token to be a single-digit integer\n        const left = this.currentToken;\n        this.eat(INTEGER);\n\n        // we expect the current token to be a '+' token\n        const operation = this.currentToken;\n        this.eat(PLUS);\n\n        // we expect the current token to be a single-digit integer\n        const right = this.currentToken;\n        this.eat(INTEGER);\n\n        // after the above call the this.currentToken is set to EOF\n\n        // at this point INTEGER PLUS INTEGER sequence of tokens\n        // has been successfully found and the method can just\n        // return the result of adding two integers, thus\n        // effectively interpreting client input\n        return left.value + right.value;\n    }\n\n}\n"]}