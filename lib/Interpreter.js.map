{"version":3,"sources":["../src/Interpreter.js"],"names":[],"mappings":"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","file":"Interpreter.js","sourcesContent":["import Token from './Token';\n\nconst INTEGER = Symbol('INTEGER');\nconst PLUS = Symbol('PLUS');\nconst MINUS = Symbol('MINUS');\nconst ASTERISK = Symbol('ASTERISK');\nconst SLASH = Symbol('SLASH');\nconst EOF = Symbol('EOF');\n\nconst isNumber = /^[0-9]$/;\nconst isWhitespace = /^\\s$/;\n\nexport default class Interpreter {\n    constructor(text) {\n        this.text = text;\n        this.position = 0;\n        this.currentToken = undefined;\n        this.currentChar = this.text.charAt(this.position);\n    }\n\n    hasNextChar() {\n        return this.position < this.text.length;\n    }\n\n    advance() {\n        this.position++;\n        this.currentChar = this.text.charAt(this.position);\n        return this.currentChar;\n    }\n\n    skipWhiteSpaces() {\n        while (this.currentChar !== '' && isWhitespace.test(this.currentChar)) {\n            this.advance();\n        }\n    }\n\n    integer() {\n        let buffer = '';\n        let currentChar = this.currentChar;\n        do {\n            buffer += currentChar;\n            currentChar = this.advance();\n        } while (isNumber.test(currentChar));\n        return Number.parseInt(buffer, 10);\n    }\n\n    /**\n     * Lexical analyzer (also known as scanner or tokenizer)\n     * This method is responsible for breaking a sentence\n     * apart into tokens. One token at a time.\n     */\n    getNextToken() {\n        this.skipWhiteSpaces();\n\n        if (this.currentChar === '') {\n            return new Token(EOF);\n        }\n\n        if (isNumber.test(this.currentChar)) {\n            return new Token(INTEGER, this.integer());\n        }\n\n        if (this.currentChar === '+') {\n            this.advance();\n            return new Token(PLUS, this.currentChar);\n        }\n\n        if (this.currentChar === '-') {\n            this.advance();\n            return new Token(MINUS, this.currentChar);\n        }\n\n        if (this.currentChar === '*') {\n            this.advance();\n            return new Token(ASTERISK, this.currentChar);\n        }\n\n        if (this.currentChar === '/') {\n            this.advance();\n            return new Token(SLASH, this.currentChar);\n        }\n\n        throw new Error('Error parsing input at position ' + this.position);\n    }\n\n    /**\n     * @param {Symbol|Symbol[]} tokenTypes\n     */\n    eat(tokenTypes) {\n        // compare the current token type with the passed token\n        // type and if they match then \"eat\" the current token\n        // and assign the next token to the this.currentToken,\n        // otherwise raise an exception.\n\n        if (!Array.isArray(tokenTypes)) {\n            tokenTypes = [tokenTypes];\n        }\n\n        if (tokenTypes.indexOf(this.currentToken.type) === -1) {\n            throw new Error('Expecting ' + tokenTypes.map(s => s.toString()).join(' or ')\n                            + ', got ' + this.currentToken.type.toString());\n        }\n\n        this.currentToken = this.getNextToken();\n    }\n\n    /**\n     * expr -> INTEGER PLUS INTEGER\n     */\n    expr() {\n        // set current token to the first token taken from the input\n        this.currentToken = this.getNextToken();\n\n        if (this.currentToken.type === EOF) {\n            return undefined;\n        }\n\n        // we expect the current token to be a single-digit integer\n        const left = this.currentToken;\n        this.eat(INTEGER);\n\n        // we expect the current token to be a '+' token\n        const operation = this.currentToken;\n        this.eat([PLUS, MINUS, ASTERISK, SLASH]);\n\n        // we expect the current token to be a single-digit integer\n        const right = this.currentToken;\n        this.eat(INTEGER);\n\n        // after the above call the this.currentToken is set to EOF\n\n        // at this point INTEGER PLUS INTEGER sequence of tokens\n        // has been successfully found and the method can just\n        // return the result of adding two integers, thus\n        // effectively interpreting client input\n        switch (operation.type) {\n            case PLUS:\n                return left.value + right.value;\n            case MINUS:\n                return left.value - right.value;\n            case ASTERISK:\n                return left.value * right.value;\n            case SLASH:\n                return left.value / right.value;\n        }\n    }\n\n}\n"]}